//Конкретная реализация класса важной детали.
//Хранит в себе детали, которые сломаются, если сломается сам кузов.
//Также отвечает за работу пассажиров. Если дверь открыта - разрешаем войти

//Хочу в этом примере затронуть проблему ООП и почему использщование его в чистом
//виде - это проблема для разработки продукта. Подводным камнем такого принципа
//является наследование. Отличный пример в этом классе. Он отвечает как за 
//разрушение прикреплённых деталей, так и попытке разрешить войти пассажиру.
//Но большая проблема ждём нас, если нам нужны будут детали, которые также
//хранят в себе другие. Наследоваться от этого класса - значит принимать
//на себя отвественность впускания, что точно будет лишним. Создавать
//подобный класс с подобным кодом - плохая практика. Что в таком случае
//можно было бы сделать? Как мне по мне, тут идеален ECS. Энтити просто
//хранит компоненты. Комноненты данные, а системы работают уже с существами
//и их данными. Но вообще, в стаком случае по-хорошему просто использовать
//паттерн стратегии для обеспечения гибкости.  

namespace SaberTestWork;

public class Body: ImportantPart
{
    private List<Door> _partsOn;
    
    private int _maxCapacity;
    private int _currentCapacity;

    public bool TryAddPassenger(Door door)
    {
        if (!door.IsOpen)
            return false;
        
        if (_currentCapacity >= _maxCapacity)
            return false;

        _currentCapacity++;

        return true;
    }

    public void RemovePassenger()
    {
        _currentCapacity--;
    }

    public override void Destroy()
    {
        base.Destroy();

        foreach (var part in _partsOn)
        {
            part.Destroy();
        }
    }
}